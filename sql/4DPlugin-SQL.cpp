/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-SQL.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : SQL
 #	author : miyako
 #	2025/07/16
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-SQL.h"

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- SQL
            
			case 1 :
				SQLGetInfo(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

#if VERSIONMAC
#define SQLGETINFOCHAR SQLCHAR
#define ob_set_sqlchar ob_set_s
#define sqlchar const char
#else
#define SQLGETINFOCHAR SQLWCHAR
#define ob_set_sqlchar ob_set_a
#define sqlchar const wchar_t
#endif

static void SQLGetInfo(PA_PluginParameters params) {

    PA_ObjectRef status = PA_CreateObject();
    
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT p2;
    p2.fromParamAtIndex(pParams, 1);
    CUTF8String connection;
    p2.copyUTF8String(&connection);
    
    ob_set_b(status, L"success", false);
    
    soci::session sql;
    
    try {
        
        soci::connection_parameters parameters(soci::odbc, (const char *)connection.c_str());
        PA_ObjectRef options = PA_GetObjectParameter(params, 3);
        if(options != NULL) {
            CUTF8String stringValue;
            if(ob_get_s(options, L"odbc_option_driver_complete", &stringValue)) {
                parameters.set_option(soci::odbc_option_driver_complete, (const char*)stringValue.c_str());
            }
        }
        sql.open(parameters);
        
        soci_mode_t mode = (soci_mode_t)PA_GetLongParameter(params, 2);
        std::unique_ptr<soci::transaction> tr;
        if(mode == soci_mode_transaction) {
            tr = std::make_unique<soci::transaction>(sql);
        }
        
        soci::odbc_session_backend* backend =
                static_cast<soci::odbc_session_backend*>(sql.get_backend());
    
        SQLHDBC hdbc = backend->hdbc_;
        
        SQLSMALLINT outlen;

        SQLGETINFOCHAR databaseName[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, 16, databaseName, sizeof(databaseName), &outlen))) {
            ob_set_sqlchar(status, L"databaseName", (sqlchar *)databaseName);
        }

        SQLGETINFOCHAR driverName[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, 6, driverName, sizeof(driverName), &outlen))) {
            ob_set_sqlchar(status, L"driverName", (sqlchar *)driverName);
        }
        
        SQLGETINFOCHAR driverVer[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, 7, driverVer, sizeof(driverVer), &outlen))) {
            ob_set_sqlchar(status, L"driverVersion", (sqlchar *)driverVer);
        }

        SQLGETINFOCHAR ODBCVer[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, 10, ODBCVer, sizeof(ODBCVer), &outlen))) {
            ob_set_sqlchar(status, L"ODBCVersion", (sqlchar *)ODBCVer);
        }

        SQLGETINFOCHAR DMVer[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, 19, DMVer, sizeof(DMVer), &outlen))) {
            ob_set_sqlchar(status, L"driverManagerVersion", (sqlchar *)DMVer);
        }
        
        SQLGETINFOCHAR DBMSVer[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, 18, DBMSVer, sizeof(DBMSVer), &outlen))) {
            ob_set_sqlchar(status, L"databaseManagementSystemVersion", (sqlchar *)DBMSVer);
        }
        
        SQLGETINFOCHAR DBMSName[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, 17, DBMSName, sizeof(DBMSName), &outlen))) {
            ob_set_sqlchar(status, L"databaseManagementSystemName", (sqlchar *)DBMSName);
        }
        
        SQLGETINFOCHAR accessibleProcedures[2];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_ACCESSIBLE_PROCEDURES, accessibleProcedures, sizeof(accessibleProcedures), &outlen))) {
            ob_set_sqlchar(status, L"accessibleProcedures", (sqlchar *)accessibleProcedures);
        }
        
        SQLGETINFOCHAR accessibleTables[2];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_ACCESSIBLE_TABLES, accessibleTables, sizeof(accessibleTables), &outlen))) {
            ob_set_sqlchar(status, L"accessibleTables", (sqlchar *)accessibleTables);
        }
                
        SQLGETINFOCHAR catalogName[2];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_CATALOG_NAME, catalogName, sizeof(catalogName), &outlen))) {
            ob_set_sqlchar(status, L"catalogName", (sqlchar *)catalogName);
        }
        
        SQLGETINFOCHAR collationSequence[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_COLLATION_SEQ, collationSequence, sizeof(collationSequence), &outlen))) {
            ob_set_sqlchar(status, L"collationSequence", (sqlchar *)collationSequence);
        }
        
        SQLGETINFOCHAR dataSourceName[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_DATA_SOURCE_NAME, dataSourceName, sizeof(dataSourceName), &outlen))) {
            ob_set_sqlchar(status, L"dataSourceName", (sqlchar *)dataSourceName);
        }
        
        SQLGETINFOCHAR serverName[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_SERVER_NAME, serverName, sizeof(serverName), &outlen))) {
            ob_set_sqlchar(status, L"serverName", (sqlchar *)serverName);
        }

        SQLGETINFOCHAR searchPatternEscape[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_SEARCH_PATTERN_ESCAPE, searchPatternEscape, sizeof(searchPatternEscape), &outlen))) {
            ob_set_sqlchar(status, L"searchPatternEscape", (sqlchar *)searchPatternEscape);
        }
                
        SQLGETINFOCHAR dataSourceReadOnly[2];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_DATA_SOURCE_READ_ONLY, dataSourceReadOnly, sizeof(dataSourceReadOnly), &outlen))) {
            ob_set_sqlchar(status, L"dataSourceReadOnly", (sqlchar *)dataSourceReadOnly);
        }
        
        SQLGETINFOCHAR identifierQuoteChar[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_IDENTIFIER_QUOTE_CHAR, identifierQuoteChar, sizeof(identifierQuoteChar), &outlen))) {
            ob_set_sqlchar(status, L"identifierQuoteChar", (sqlchar *)identifierQuoteChar);
        }
                        
        SQLGETINFOCHAR userName[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_USER_NAME, userName, sizeof(userName), &outlen))) {
            ob_set_sqlchar(status, L"userName", (sqlchar *)userName);
        }
                
        SQLGETINFOCHAR integrity[2];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_INTEGRITY, integrity, sizeof(integrity), &outlen))) {
            ob_set_sqlchar(status, L"integrity", (sqlchar *)integrity);
        }
        
        SQLGETINFOCHAR orderByColumnsInSelect[2];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_ORDER_BY_COLUMNS_IN_SELECT, orderByColumnsInSelect, sizeof(orderByColumnsInSelect), &outlen))) {
            ob_set_sqlchar(status, L"orderByColumnsInSelect", (sqlchar *)orderByColumnsInSelect);
        }
        
        SQLGETINFOCHAR specialCharacters[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_SPECIAL_CHARACTERS, specialCharacters, sizeof(specialCharacters), &outlen))) {
            ob_set_sqlchar(status, L"specialCharacters", (sqlchar *)specialCharacters);
        }

        SQLGETINFOCHAR xopenCLIYear[1024];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_XOPEN_CLI_YEAR, xopenCLIYear, sizeof(xopenCLIYear), &outlen))) {
            ob_set_sqlchar(status, L"xopenCLIYear", (sqlchar *)xopenCLIYear);
        }
        
        SQLGETINFOCHAR describeParameter[2];
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_DESCRIBE_PARAMETER, describeParameter, sizeof(describeParameter), &outlen))) {
            ob_set_sqlchar(status, L"describeParameter", (sqlchar *)describeParameter);
        }

#pragma mark SQLUSMALLINT
        
        SQLUSMALLINT maximumDriverConnections;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_DRIVER_CONNECTIONS, &maximumDriverConnections, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumDriverConnections", maximumDriverConnections);
        }

        SQLUSMALLINT maximumConcurrentActivities;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_CONCURRENT_ACTIVITIES, &maximumConcurrentActivities, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumConcurrentActivities", maximumConcurrentActivities);
        }
        
        SQLUSMALLINT cursorCommitBehavior;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_CURSOR_COMMIT_BEHAVIOR, &cursorCommitBehavior, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "cursorCommitBehavior", cursorCommitBehavior);
        }
        
        SQLUSMALLINT identifierCase;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_IDENTIFIER_CASE, &identifierCase, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "identifierCase", identifierCase);
        }
        
        SQLUSMALLINT maximumColumnNameLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_COLUMN_NAME_LEN, &maximumColumnNameLength, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumColumnNameLength", maximumColumnNameLength);
        }
        
        SQLUSMALLINT maximumCursorNameLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_CURSOR_NAME_LEN, &maximumCursorNameLength, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumCursorNameLength", maximumCursorNameLength);
        }
        
        SQLUSMALLINT maximumSchemaNameLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_SCHEMA_NAME_LEN, &maximumSchemaNameLength, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumSchemaNameLength", maximumSchemaNameLength);
        }
        
        SQLUSMALLINT nullCollation;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_NULL_COLLATION, &nullCollation, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "nullCollation", nullCollation);
        }
        
        SQLUSMALLINT maximumColumnsInGroupBy;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_COLUMNS_IN_GROUP_BY, &maximumColumnsInGroupBy, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumColumnsInGroupBy", maximumColumnsInGroupBy);
        }
        
        SQLUSMALLINT maximumColumnsInIndex;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_COLUMNS_IN_INDEX, &maximumColumnsInIndex, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumColumnsInIndex", maximumColumnsInIndex);
        }
        
        SQLUSMALLINT maximumColumnsInOrderBy;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_COLUMNS_IN_ORDER_BY, &maximumColumnsInOrderBy, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumColumnsInOrderBy", maximumColumnsInOrderBy);
        }
        
        SQLUSMALLINT maximumColumnsInSelect;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_COLUMNS_IN_SELECT, &maximumColumnsInSelect, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumColumnsInSelect", maximumColumnsInSelect);
        }
        
        SQLUSMALLINT maximumColumnsInTable;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_COLUMNS_IN_TABLE, &maximumColumnsInTable, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumColumnsInTable", maximumColumnsInTable);
        }
        
        SQLUSMALLINT maximumTablesInSelect;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_TABLES_IN_SELECT, &maximumTablesInSelect, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumTablesInSelect", maximumTablesInSelect);
        }
        
        SQLUSMALLINT maximumUserNameLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_USER_NAME_LEN, &maximumUserNameLength, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumUserNameLength", maximumUserNameLength);
        }
        
        SQLUSMALLINT maximumCatalogNameLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_CATALOG_NAME_LEN, &maximumCatalogNameLength, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumCatalogNameLength", maximumCatalogNameLength);
        }
        
        SQLUSMALLINT maximumTableNameLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_TABLE_NAME_LEN, &maximumTableNameLength, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "maximumTableNameLength", maximumTableNameLength);
        }
        
        SQLUSMALLINT transactionCapable;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_TXN_CAPABLE, &transactionCapable, sizeof(SQLUSMALLINT), &outlen))) {
            ob_set_n(status, "transactionCapable", transactionCapable);
        }
        
#pragma mark SQLINTEGER
        
        SQLINTEGER fetchDirection;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_FETCH_DIRECTION, &fetchDirection, sizeof(SQLINTEGER), &outlen))) {
            ob_set_n(status, "fetchDirection", fetchDirection);
        }
        
        SQLINTEGER scrollConcurrency;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_SCROLL_CONCURRENCY, &scrollConcurrency, sizeof(SQLINTEGER), &outlen))) {
            ob_set_n(status, "scrollConcurrency", scrollConcurrency);
        }
        
#pragma mark SQLUINTEGER
        
        SQLUINTEGER alterTable;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_ALTER_TABLE, &alterTable, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "alterTable", alterTable);
        }
        
        SQLUINTEGER defaultTransactionIsolation;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_DEFAULT_TXN_ISOLATION, &defaultTransactionIsolation, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "defaultTransactionIsolation", defaultTransactionIsolation);
        }
        
        SQLUINTEGER transactionIsolationOption;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_TXN_ISOLATION_OPTION, &transactionIsolationOption, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "transactionIsolationOption", transactionIsolationOption);
        }
        
        SQLUINTEGER getdataExtensions;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_GETDATA_EXTENSIONS, &getdataExtensions, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "getdataExtensions", getdataExtensions);
        }
        
        SQLUINTEGER maximumIndexSize;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_INDEX_SIZE, &maximumIndexSize, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "maximumIndexSize", maximumIndexSize);
        }
        
        SQLUINTEGER maximumRowSize;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_ROW_SIZE, &maximumRowSize, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "maximumRowSize", maximumRowSize);
        }
        
        SQLUINTEGER maximumStatementLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_STATEMENT_LEN, &maximumStatementLength, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "maximumStatementLength", maximumStatementLength);
        }
        
        SQLUINTEGER outerJoinCapabilites;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_OJ_CAPABILITIES, &outerJoinCapabilites, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "outerJoinCapabilites", outerJoinCapabilites);
        }
        
        SQLUINTEGER cursorSensitivity;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_CURSOR_SENSITIVITY, &cursorSensitivity, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "cursorSensitivity", cursorSensitivity);
        }
        
        SQLUINTEGER maximumIdentifierLength;
        if (SQL_SUCCEEDED(SQLGetInfo(hdbc, SQL_MAX_IDENTIFIER_LEN, &maximumIdentifierLength, sizeof(SQLUINTEGER), &outlen))) {
            ob_set_n(status, "maximumIdentifierLength", maximumIdentifierLength);
        }
        
        if(mode == soci_mode_transaction) {
            tr->commit();
            tr.reset(); // destroy transaction object
        }
        ob_set_b(status, L"success", true);
    
    } catch (const std::exception& e) {
        ob_set_s(status, "errorMessage", e.what());
        ob_set_b(status, L"success", false);
    }
    PA_ReturnObject(params, status);
}
